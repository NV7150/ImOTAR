#pragma kernel KInit
#pragma kernel KGSRed
#pragma kernel KGSBlack
#pragma kernel KFinalize

// Poisson depth densification with red-black Gaussâ€“Seidel in-place updates.
// Inputs:
//  - _SparseDepth (RFloat, meters): sparse depth; invalid when < 0
//  - _TempDepth   (RFloat, meters): temporal depth (history); invalid when < 0
//  - _EdgeTex     (RFloat, 0..1): continuous edge strength at RGB resolution
// Output:
//  - _Output (RFloat): final solution, updated in place by GS passes
//  - _History (RFloat): copied from _Output at finalize for next frame
// No CPU-side intermediate RenderTextures; all work is inside this shader.

Texture2D<float> _SparseDepth;   // SRV
Texture2D<float> _TempDepth;     // SRV (history)
Texture2D<float> _EdgeTex;       // SRV (edge at RGB size)

RWTexture2D<float> _Output;      // UAV: solution buffer (in-place GS)
RWTexture2D<float> _History;     // UAV: history copy target

int _Width;
int _Height;
int _EdgeWidth;
int _EdgeHeight;

// (lambda_d, lambda_t, lambda_s)
float3 _Lambda;
// Denominator clamp for stability
float _EpsDen;
// Edge strength scaling for smoothness weights (higher -> stronger edge suppression)
float _EdgeScale;
// 0 = point sample edge, 1 = bilinear sample
int _EdgeBilinear;
// 0 = soft suppression only, 1 = hard cut when edge XOR between p and q (not used by default)
int _HardEdgeCut;
// Valid threshold for depth (depth >= _ValidThresh => valid). Set to 0.0 so that 0m is valid.
float _ValidThresh;

// Utility: clamp coordinates to valid range
int2 ClampCoord(int2 q)
{
	q.x = clamp(q.x, 0, _Width - 1);
	q.y = clamp(q.y, 0, _Height - 1);
	return q;
}

// Map depth pixel p to edge texture continuous coordinates
float2 DepthToEdgeUV(int2 p)
{
	// Convert to edge pixel coordinates then to [0,1] UV
	float2 exy = (float2(p) + 0.5) * float2(_EdgeWidth, _EdgeHeight) / float2(_Width, _Height) - 0.5;
	float2 e0 = max(exy, 0.0);
	float2 e1 = min(e0, float2(_EdgeWidth - 1, _EdgeHeight - 1));
	float2 uv = (e1 + 0.5) / float2(_EdgeWidth, _EdgeHeight);
	return uv;
}

// Point sample edge at nearest pixel corresponding to depth pixel p
float SampleEdgePoint(int2 p)
{
	float2 exy = (float2(p) + 0.5) * float2(_EdgeWidth, _EdgeHeight) / float2(_Width, _Height) - 0.5;
	int2 ei = int2(round(exy));
	ei.x = clamp(ei.x, 0, _EdgeWidth - 1);
	ei.y = clamp(ei.y, 0, _EdgeHeight - 1);
	return _EdgeTex.Load(int3(ei, 0));
}

// Manual bilinear sample to avoid samplers and branches
float SampleEdgeBilinear(int2 p)
{
	float2 exy = (float2(p) + 0.5) * float2(_EdgeWidth, _EdgeHeight) / float2(_Width, _Height) - 0.5;
	float2 f = floor(exy);
	int2 i0 = int2(f);
	int2 i1 = i0 + int2(1, 0);
	int2 j0 = i0 + int2(0, 1);
	int2 j1 = i0 + int2(1, 1);
	float2 t = saturate(exy - f);

	i0.x = clamp(i0.x, 0, _EdgeWidth - 1);
	i0.y = clamp(i0.y, 0, _EdgeHeight - 1);
	i1.x = clamp(i1.x, 0, _EdgeWidth - 1);
	i1.y = clamp(i1.y, 0, _EdgeHeight - 1);
	j0.x = clamp(j0.x, 0, _EdgeWidth - 1);
	j0.y = clamp(j0.y, 0, _EdgeHeight - 1);
	j1.x = clamp(j1.x, 0, _EdgeWidth - 1);
	j1.y = clamp(j1.y, 0, _EdgeHeight - 1);

	float e00 = _EdgeTex.Load(int3(i0, 0));
	float e10 = _EdgeTex.Load(int3(i1, 0));
	float e01 = _EdgeTex.Load(int3(j0, 0));
	float e11 = _EdgeTex.Load(int3(j1, 0));
	float ex0 = lerp(e00, e10, t.x);
	float ex1 = lerp(e01, e11, t.x);
	return lerp(ex0, ex1, t.y);
}

float SampleEdge(int2 p)
{
	float ep = SampleEdgePoint(p);
	float eb = SampleEdgeBilinear(p);
	float mask = (float)_EdgeBilinear;
	return lerp(ep, eb, mask);
}

// Compute smoothness weight between p and q using continuous edge values
float NeighborWeight(int2 p, int2 q)
{
	float ep = SampleEdge(p);
	float eq = SampleEdge(q);
	float s = min(ep, eq);
	float w = saturate(1.0 - s * _EdgeScale);
	if (_HardEdgeCut != 0)
	{
		// Optional hard cut: if one is strong edge and the other is not, cut connection.
		// Threshold at 0.5 without magic numbers would be parameterized; here we reuse _EdgeScale as continuous control,
		// but hard cut path is disabled by default in C# (set _HardEdgeCut = 0).
		// Note: we keep the branch but it's controlled by a uniform and not per-pixel divergence in practice.
	}
	return w;
}

[numthreads(16, 16, 1)]
void KInit(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= (uint)_Width || id.y >= (uint)_Height) return;
	int2 p = int2(id.xy);
	float ds = _SparseDepth.Load(int3(p, 0));
	float dt = _TempDepth.Load(int3(p, 0));
	float ws = step(_ValidThresh, ds);
	float wt = step(_ValidThresh, dt);
	float d0 = ws * ds + (1.0 - ws) * (wt * dt);
	_Output[p] = d0;
}

// Shared update core: compute updated depth from neighbors and data/temporal terms
float UpdateDepth(int2 p)
{
	int2 l = ClampCoord(p + int2(-1, 0));
	int2 r = ClampCoord(p + int2( 1, 0));
	int2 u = ClampCoord(p + int2( 0,-1));
	int2 d = ClampCoord(p + int2( 0, 1));

	float dl = _Output[l];
	float dr = _Output[r];
	float du = _Output[u];
	float dd = _Output[d];

	float wl = NeighborWeight(p, l);
	float wr = NeighborWeight(p, r);
	float wu = NeighborWeight(p, u);
	float wd = NeighborWeight(p, d);

	float ds = _SparseDepth.Load(int3(p, 0));
	float dt = _TempDepth.Load(int3(p, 0));
	float ws = step(_ValidThresh, ds);
	float wt = step(_ValidThresh, dt);

	float num = _Lambda.x * ws * ds + _Lambda.y * wt * dt + _Lambda.z * (wl * dl + wr * dr + wu * du + wd * dd);
	float den = _Lambda.x * ws + _Lambda.y * wt + _Lambda.z * (wl + wr + wu + wd);
	den = max(den, _EpsDen);
	return num / den;
}

[numthreads(16, 16, 1)]
void KGSRed(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= (uint)_Width || id.y >= (uint)_Height) return;
	int2 p = int2(id.xy);
	int parity = (p.x + p.y) & 1; // 0 = red, 1 = black
	float oldD = _Output[p];
	float newD = UpdateDepth(p);
	float mask = 1.0 - (float)parity; // update only red
	_Output[p] = lerp(oldD, newD, mask);
}

[numthreads(16, 16, 1)]
void KGSBlack(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= (uint)_Width || id.y >= (uint)_Height) return;
	int2 p = int2(id.xy);
	int parity = (p.x + p.y) & 1; // 0 = red, 1 = black
	float oldD = _Output[p];
	float newD = UpdateDepth(p);
	float mask = (float)parity; // update only black
	_Output[p] = lerp(oldD, newD, mask);
}

[numthreads(16, 16, 1)]
void KFinalize(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= (uint)_Width || id.y >= (uint)_Height) return;
	int2 p = int2(id.xy);
	float d = _Output[p];
	_History[p] = d;
}


