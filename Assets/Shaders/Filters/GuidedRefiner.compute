#pragma kernel KPrep
#pragma kernel KBoxH
#pragma kernel KBoxV
#pragma kernel KCoeff
#pragma kernel KCompose

// 16x16 thread groups as specified
[numthreads(16,16,1)]
void KPrep(uint3 id : SV_DispatchThreadID);
[numthreads(16,16,1)]
void KBoxH(uint3 id : SV_DispatchThreadID);
[numthreads(16,16,1)]
void KBoxV(uint3 id : SV_DispatchThreadID);
[numthreads(16,16,1)]
void KCoeff(uint3 id : SV_DispatchThreadID);
[numthreads(16,16,1)]
void KCompose(uint3 id : SV_DispatchThreadID);

// Uniforms
int _Width;
int _Height;
int _Radius;        // box radius (pixels)
int _KernelSize;    // 2*_Radius+1
float _Epsilon;     // meters^2
float _EdgeEpsScale;// >= 1

// Textures
Texture2D<float> _DepthTex;      // RFloat, meters
Texture2D<float> _EdgeTex;       // RFloat, 0..1 (RGB resolution)

RWTexture2D<float> _GTex;        // masked guidance (G * M) at depth grid
RWTexture2D<float> _PTex;        // masked depth (P * M)
RWTexture2D<float> _G2Tex;       // masked G^2 (G*G * M)
RWTexture2D<float> _GPTex;       // masked G*P ((G*P) * M)
RWTexture2D<float> _MaskTex;     // binary mask M (1 if depth >= 0 and finite, else 0)

RWTexture2D<float> _TempTex;     // horizontal box sums temp
RWTexture2D<float> _OutTex;      // vertical box -> mean output

Texture2D<float> _InTex;         // generic read for box passes

// Means
Texture2D<float> _MeanG;
Texture2D<float> _MeanP;
Texture2D<float> _MeanG2;
Texture2D<float> _MeanGP;

RWTexture2D<float> _ATex;
RWTexture2D<float> _BTex;

Texture2D<float> _MeanA;
Texture2D<float> _MeanB;

RWTexture2D<float> _Output;      // final refined depth

// Mask sums (box-filtered). We reuse the generic box filter to compute sums for all fields.
Texture2D<float> _MeanM;         // sum of mask over window

// Numerical safety for division by zero in masked means
float _EpsCount;                  // small positive value
int _MinValidCount;               // minimum valid samples to keep output

// Helper: clamp to bounds
int2 ClampCoord(int2 p)
{
    p.x = clamp(p.x, 0, _Width - 1);
    p.y = clamp(p.y, 0, _Height - 1);
    return p;
}

// KPrep: prepare G, P, G^2, G*P on depth grid
void KPrep(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _Width || id.y >= _Height) return;
    int2 p = int2(id.xy);

    float depth = _DepthTex.Load(int3(p, 0));

    // Sample edge by normalized UV mapping to edge texture resolution
    // Compute edge pixel via manual mapping since SampleLevel with sampler isn't directly available
    uint edgeW, edgeH;
    _EdgeTex.GetDimensions(edgeW, edgeH);
    float2 uv = (float2(p) + 0.5) / float2(_Width, _Height);
    int2 ePix = int2(saturate(uv) * float2(edgeW, edgeH));
    ePix = int2(min(ePix, int2(edgeW - 1, edgeH - 1)));
    float guide = _EdgeTex.Load(int3(ePix, 0));

    // Build validity mask: 1 if finite and depth >= 0, else 0
    float mFinite = isfinite(depth) ? 1.0 : 0.0;
    float mPos    = step(0.0, depth);
    float M       = saturate(mFinite * mPos);

    // Write masked fields and mask texture
    _MaskTex[p] = M;
    _GTex[p]  = guide * M;
    _PTex[p]  = depth * M;
    _G2Tex[p] = guide * guide * M;
    _GPTex[p] = guide * depth * M;
}

// Horizontal box pass: prefix-like sliding window, clamped borders (minimal implementation)
void KBoxH(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _Width || id.y >= _Height) return;
    int2 p = int2(id.xy);

    // Compute sum along X for window centered at p with radius _Radius
    float sum = 0.0;
    for (int dx = -_Radius; dx <= _Radius; ++dx)
    {
        int2 q = p + int2(dx, 0);
        q = ClampCoord(q);
        sum += _InTex.Load(int3(q, 0));
    }
    _TempTex[p] = sum;
}

// Vertical box pass: take horizontal sums and sum along Y, then divide by area
void KBoxV(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _Width || id.y >= _Height) return;
    int2 p = int2(id.xy);

    float sum = 0.0;
    for (int dy = -_Radius; dy <= _Radius; ++dy)
    {
        int2 q = p + int2(0, dy);
        q = ClampCoord(q);
        sum += _InTex.Load(int3(q, 0));
    }
    // Output raw sum (no normalization here). Means are formed later by dividing by mask sums.
    _OutTex[p] = sum;
}

// KCoeff: compute a and b with edge-modulated epsilon
void KCoeff(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _Width || id.y >= _Height) return;
    int2 p = int2(id.xy);

    // Read summed fields and mask sum, then form masked means
    float sumG  = _MeanG.Load(int3(p, 0));
    float sumP  = _MeanP.Load(int3(p, 0));
    float sumG2 = _MeanG2.Load(int3(p, 0));
    float sumGP = _MeanGP.Load(int3(p, 0));
    float sumM  = _MeanM.Load(int3(p, 0));

    float invDen = rcp(max(sumM, _EpsCount));
    float meanG  = sumG  * invDen;
    float meanP  = sumP  * invDen;
    float meanG2 = sumG2 * invDen;
    float meanGP = sumGP * invDen;
    float guide  = _GTex[p];

    float varG = max(0.0, meanG2 - meanG * meanG);
    float covGP = meanGP - meanG * meanP;

    // epsilon modulation based on local guide (edge)
    float epsLocal = _Epsilon * lerp(1.0, _EdgeEpsScale, saturate(guide));

    float a = covGP / (varG + epsLocal);
    float b = meanP - a * meanG;

    _ATex[p] = a;
    _BTex[p] = b;
}

// KCompose: q = meanA * G + meanB
void KCompose(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _Width || id.y >= _Height) return;
    int2 p = int2(id.xy);
    // Normalize meanA/meanB by mask sum and compose, then invalidate when window has no valid samples
    float sumM = _MeanM.Load(int3(p, 0));
    float invDen = rcp(max(sumM, _EpsCount));
    float meanA = _MeanA.Load(int3(p, 0)) * invDen;
    float meanB = _MeanB.Load(int3(p, 0)) * invDen;

    float q = meanA * _GTex[p] + meanB;
    float keep = step((float)_MinValidCount - 0.5, sumM);
    _Output[p] = lerp(-1.0, q, keep);
}
