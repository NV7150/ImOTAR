#pragma kernel ResetBuffers
#pragma kernel Pass1_CountMax
#pragma kernel Pass2_ComputeScale
#pragma kernel Pass3_Sum
#pragma kernel Pass4_Write

// 2D thread group size for image-sized passes
[numthreads(16, 16, 1)]
void Pass1_CountMax(uint3 id : SV_DispatchThreadID);
[numthreads(16, 16, 1)]
void Pass3_Sum(uint3 id : SV_DispatchThreadID);
[numthreads(16, 16, 1)]
void Pass4_Write(uint3 id : SV_DispatchThreadID);

// 1D thread group size for region-indexed passes
[numthreads(256, 1, 1)]
void ResetBuffers(uint3 id : SV_DispatchThreadID);
[numthreads(256, 1, 1)]
void Pass2_ComputeScale(uint3 id : SV_DispatchThreadID);

// Resources
Texture2D<float>   _DepthTex;
Texture2D<float4>  _RegionTex;
Texture2D<float>   _PrevOutput; // previous smoothed output (RFloat)
RWTexture2D<float> _Output; // RFloat

RWStructuredBuffer<uint> _Count;        // count per id
RWStructuredBuffer<uint> _MaxDepthMm;   // max depth per id (millimeters)
RWStructuredBuffer<uint> _SumScaled;    // sum of (depth * scale[id]) per id
RWStructuredBuffer<uint> _Scale;        // scale per id (unit: 1/m)

// Params
cbuffer Params {
    uint2 _RegionSize; // (w, h)
    uint2 _DepthSize;  // (w, h)
    uint  _NumRegions; // maxId + 1
    int   _ZeroRegionMode; // 0:-1, 1:0, 2:treat as region, 3:passthrough
    int   _UseEMA; // 0/1
    int   _PrevValid; // 0/1
    float _AlphaInner; // 0..1
    float _AlphaBoundary; // 0..1
}

// Helpers
static const uint UINT_MAX_SAFE = 0xFFFFFFEF; // margin to avoid exact overflow

uint DecodeRegionId(float4 c01)
{
    // 同等処理のベクトル化（分岐なし）
    uint4 p = (uint4)round(saturate(c01) * 255.0);
    return p.x | (p.y << 8) | (p.z << 16) | (p.w << 24);
}

int2 MapRegionToDepth(uint2 rp)
{
    // Map region pixel center to depth pixel index (nearest)
    // dx = floor((x+0.5)*Dw/Rw), dy = floor((y+0.5)*Dh/Rh)
    float2 rsz = float2(_RegionSize);
    float2 dsz = float2(_DepthSize);
    float2 fc = (float2(rp) + 0.5) * dsz / rsz;
    int2 dp = int2(floor(fc));
    dp.x = clamp(dp.x, 0, int(_DepthSize.x) - 1);
    dp.y = clamp(dp.y, 0, int(_DepthSize.y) - 1);
    return dp;
}

bool IsDepthValid(float d)
{
    // reject non-positive or NaN/Inf
    return (d > 0.0) && (d == d) && isfinite(d);
}

// --- 3x3 mode filter for region labels (majority vote with center-preferred tie break) ---
uint SampleRegionIdClamped(int2 p)
{
    p.x = clamp(p.x, 0, int(_RegionSize.x) - 1);
    p.y = clamp(p.y, 0, int(_RegionSize.y) - 1);
    return DecodeRegionId(_RegionTex.Load(int3(uint2(p), 0)));
}

uint ModeLabel3x3(uint2 rp)
{
    int2 p = int2(rp);

    // Sample 3x3 neighborhood (clamped at borders)
    uint l00 = SampleRegionIdClamped(p + int2(-1, -1));
    uint l10 = SampleRegionIdClamped(p + int2( 0, -1));
    uint l20 = SampleRegionIdClamped(p + int2( 1, -1));
    uint l01 = SampleRegionIdClamped(p + int2(-1,  0));
    uint l11 = SampleRegionIdClamped(p + int2( 0,  0)); // center
    uint l21 = SampleRegionIdClamped(p + int2( 1,  0));
    uint l02 = SampleRegionIdClamped(p + int2(-1,  1));
    uint l12 = SampleRegionIdClamped(p + int2( 0,  1));
    uint l22 = SampleRegionIdClamped(p + int2( 1,  1));

    // Count matches for each of the 9 samples (fully unrolled)
    // Using ternary selects which typically compile to predicated ops (no control-flow branching)
    uint c00 = (l00==l00?1u:0u)+(l00==l10?1u:0u)+(l00==l20?1u:0u)+(l00==l01?1u:0u)+(l00==l11?1u:0u)+(l00==l21?1u:0u)+(l00==l02?1u:0u)+(l00==l12?1u:0u)+(l00==l22?1u:0u);
    uint c10 = (l10==l00?1u:0u)+(l10==l10?1u:0u)+(l10==l20?1u:0u)+(l10==l01?1u:0u)+(l10==l11?1u:0u)+(l10==l21?1u:0u)+(l10==l02?1u:0u)+(l10==l12?1u:0u)+(l10==l22?1u:0u);
    uint c20 = (l20==l00?1u:0u)+(l20==l10?1u:0u)+(l20==l20?1u:0u)+(l20==l01?1u:0u)+(l20==l11?1u:0u)+(l20==l21?1u:0u)+(l20==l02?1u:0u)+(l20==l12?1u:0u)+(l20==l22?1u:0u);
    uint c01 = (l01==l00?1u:0u)+(l01==l10?1u:0u)+(l01==l20?1u:0u)+(l01==l01?1u:0u)+(l01==l11?1u:0u)+(l01==l21?1u:0u)+(l01==l02?1u:0u)+(l01==l12?1u:0u)+(l01==l22?1u:0u);
    uint c11 = (l11==l00?1u:0u)+(l11==l10?1u:0u)+(l11==l20?1u:0u)+(l11==l01?1u:0u)+(l11==l11?1u:0u)+(l11==l21?1u:0u)+(l11==l02?1u:0u)+(l11==l12?1u:0u)+(l11==l22?1u:0u);
    uint c21 = (l21==l00?1u:0u)+(l21==l10?1u:0u)+(l21==l20?1u:0u)+(l21==l01?1u:0u)+(l21==l11?1u:0u)+(l21==l21?1u:0u)+(l21==l02?1u:0u)+(l21==l12?1u:0u)+(l21==l22?1u:0u);
    uint c02 = (l02==l00?1u:0u)+(l02==l10?1u:0u)+(l02==l20?1u:0u)+(l02==l01?1u:0u)+(l02==l11?1u:0u)+(l02==l21?1u:0u)+(l02==l02?1u:0u)+(l02==l12?1u:0u)+(l02==l22?1u:0u);
    uint c12 = (l12==l00?1u:0u)+(l12==l10?1u:0u)+(l12==l20?1u:0u)+(l12==l01?1u:0u)+(l12==l11?1u:0u)+(l12==l21?1u:0u)+(l12==l02?1u:0u)+(l12==l12?1u:0u)+(l12==l22?1u:0u);
    uint c22 = (l22==l00?1u:0u)+(l22==l10?1u:0u)+(l22==l20?1u:0u)+(l22==l01?1u:0u)+(l22==l11?1u:0u)+(l22==l21?1u:0u)+(l22==l02?1u:0u)+(l22==l12?1u:0u)+(l22==l22?1u:0u);

    // Start with center (tie-breaker)
    uint bestLabel = l11;
    uint bestCount = c11;

    // Branch-minimized selection using step/lerp; updates only on strictly greater count
    {
        float gt = step((float)bestCount + 0.5, (float)c00);
        bestCount = (uint)lerp((float)bestCount, (float)c00, gt);
        bestLabel = (uint)lerp((float)bestLabel, (float)l00, gt);
    }
    {
        float gt = step((float)bestCount + 0.5, (float)c10);
        bestCount = (uint)lerp((float)bestCount, (float)c10, gt);
        bestLabel = (uint)lerp((float)bestLabel, (float)l10, gt);
    }
    {
        float gt = step((float)bestCount + 0.5, (float)c20);
        bestCount = (uint)lerp((float)bestCount, (float)c20, gt);
        bestLabel = (uint)lerp((float)bestLabel, (float)l20, gt);
    }
    {
        float gt = step((float)bestCount + 0.5, (float)c01);
        bestCount = (uint)lerp((float)bestCount, (float)c01, gt);
        bestLabel = (uint)lerp((float)bestLabel, (float)l01, gt);
    }
    {
        // center already seeded; skipping c11 ensures center tie-break is preserved
    }
    {
        float gt = step((float)bestCount + 0.5, (float)c21);
        bestCount = (uint)lerp((float)bestCount, (float)c21, gt);
        bestLabel = (uint)lerp((float)bestLabel, (float)l21, gt);
    }
    {
        float gt = step((float)bestCount + 0.5, (float)c02);
        bestCount = (uint)lerp((float)bestCount, (float)c02, gt);
        bestLabel = (uint)lerp((float)bestLabel, (float)l02, gt);
    }
    {
        float gt = step((float)bestCount + 0.5, (float)c12);
        bestCount = (uint)lerp((float)bestCount, (float)c12, gt);
        bestLabel = (uint)lerp((float)bestLabel, (float)l12, gt);
    }
    {
        float gt = step((float)bestCount + 0.5, (float)c22);
        bestCount = (uint)lerp((float)bestCount, (float)c22, gt);
        bestLabel = (uint)lerp((float)bestLabel, (float)l22, gt);
    }

    return bestLabel;
}

float ComputeBoundaryAlpha(uint2 rp, uint ridCenter)
{
    // Cheap boundary check: compare with right and down neighbors (clamped)
    int2 p = int2(rp);
    uint ridR = SampleRegionIdClamped(p + int2(1, 0));
    uint ridD = SampleRegionIdClamped(p + int2(0, 1));
    float nb = 0.0;
    nb += (ridCenter != ridR) ? 1.0 : 0.0;
    nb += (ridCenter != ridD) ? 1.0 : 0.0;
    float isBoundary = step(0.5, nb); // >0 -> 1
    return lerp(_AlphaInner, _AlphaBoundary, isBoundary);
}

// -------------------- Kernels --------------------

void ResetBuffers(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _NumRegions) return;
    _Count[idx] = 0u;
    _MaxDepthMm[idx] = 0u;
    _SumScaled[idx] = 0u;
    _Scale[idx] = 0u;
}

void Pass1_CountMax(uint3 id : SV_DispatchThreadID)
{
    // 境界チェックは残す
    if (id.x >= _RegionSize.x || id.y >= _RegionSize.y) return;

    uint2 rp = id.xy;
    int2 dp = MapRegionToDepth(rp);

    float depth = _DepthTex.Load(int3(dp, 0));
    uint  rid   = ModeLabel3x3(rp);

    // --- 分岐の代わりにマスク ---
    // valid depth mask
    uint m_depth = IsDepthValid(depth) ? 1u : 0u;
    // zero-region handling mask
    uint m_zero  = (_ZeroRegionMode == 2) ? 1u : 0u;
    // non-zero region id mask
    uint m_rid   = (rid != 0u) ? 1u : 0u;
    // use mask
    uint m_use   = (m_rid | m_zero) & m_depth;

    // Count += m_use
    InterlockedAdd(_Count[rid], m_use);

    // MaxDepthMm = max(MaxDepthMm, dmm * m_use)
    float dmmF = clamp(depth * 1000.0, 0.0, 4.294e9);
    uint  dmm  = (uint)round(dmmF);
    uint  cand = dmm * m_use; // not used => 0
    InterlockedMax(_MaxDepthMm[rid], cand);
}

void Pass2_ComputeScale(uint3 id : SV_DispatchThreadID)
{
    uint rid = id.x;
    if (rid >= _NumRegions) return;

    uint cnt   = _Count[rid];
    uint maxMm = _MaxDepthMm[rid];

    // Branchless computation with mask
    float denom = max(1e-6, (float)cnt * (float)maxMm * (1.0 / 1000.0));
    float s = floor((float)UINT_MAX_SAFE / denom);
    s = clamp(s, 1.0, 1.0e9);

    // masks as floats (0.0 or 1.0)
    float cntMask = (cnt  > 0u) ? 1.0 : 0.0;
    float maxMask = (maxMm > 0u) ? 1.0 : 0.0;
    float useMask = cntMask * maxMask;

    uint scale = (uint)max(1.0, s * useMask);
    _Scale[rid] = scale;
}

void Pass3_Sum(uint3 id : SV_DispatchThreadID)
{
    // 境界チェックは残す
    if (id.x >= _RegionSize.x || id.y >= _RegionSize.y) return;

    uint2 rp = id.xy;
    int2 dp = MapRegionToDepth(rp);

    float depth = _DepthTex.Load(int3(dp, 0));
    uint  rid   = ModeLabel3x3(rp);

    // --- 分岐の代わりにマスク ---
    uint m_depth = IsDepthValid(depth) ? 1u : 0u;
    uint m_zero  = (_ZeroRegionMode == 2) ? 1u : 0u;
    uint m_rid   = (rid != 0u) ? 1u : 0u;
    uint m_use   = (m_rid | m_zero) & m_depth;

    uint  scale   = max(_Scale[rid], 1u);
    float scaledF = clamp(depth * (float)scale, 0.0, 4.294e9);
    uint  scaled  = (uint)round(scaledF);

    // SumScaled += scaled * m_use
    InterlockedAdd(_SumScaled[rid], scaled * m_use);
}

void Pass4_Write(uint3 id : SV_DispatchThreadID)
{
    // 安全のため境界チェックを追加
    if (id.x >= _RegionSize.x || id.y >= _RegionSize.y) return;

    uint2 rp = id.xy;
    int2 dp  = MapRegionToDepth(rp);

    float depth = _DepthTex.Load(int3(dp, 0));
    uint  rid   = ModeLabel3x3(rp);

    // Compute mean branchlessly for any rid
    uint  cnt   = _Count[rid];
    uint  scale = max(_Scale[rid], 1u);
    uint  sum   = _SumScaled[rid];

    float cntMask = (cnt > 0u) ? 1.0 : 0.0; // 1 if cnt>0
    float denom   = max(1.0, (float)cnt * (float)scale);
    float meanCandidate = (float)sum / denom;
    float meanVal = lerp(-1.0, meanCandidate, cntMask);

    // Zero-region mode selection without branches
    float isZeroF = (rid == 0u) ? 1.0 : 0.0;
    float modeF = (float)_ZeroRegionMode;
    float m0 = (modeF == 0.0) ? 1.0 : 0.0; // MinusOne
    float m1 = (modeF == 1.0) ? 1.0 : 0.0; // Zero
    float m2 = (modeF == 2.0) ? 1.0 : 0.0; // TreatAsRegion
    float m3 = (modeF == 3.0) ? 1.0 : 0.0; // PassthroughDepth
    float zeroOut = (-1.0) * m0 + 0.0 * m1 + meanVal * m2 + depth * m3;

    float outNonZero = meanVal;
    float outVal = lerp(outNonZero, zeroOut, isZeroF);

    // EMA temporal smoothing (optional)
    // Compute alpha per-pixel using simple boundary check
    float alpha = ComputeBoundaryAlpha(rp, rid);
    float prevVal = _PrevOutput[rp];
    float useEma = (_UseEMA != 0) ? 1.0 : 0.0;
    float prevOk = (_PrevValid != 0) ? 1.0 : 0.0;
    float emaVal = lerp(prevVal, outVal, alpha);
    outVal = lerp(outVal, emaVal, useEma * prevOk);

    // Write without Y flip to match region/depth textures as provided.
    _Output[rp] = outVal;
}
