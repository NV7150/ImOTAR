<!-- c0664623-cb98-47b4-87dd-a5333a9f8596 c39fa1aa-2002-48be-8a3f-4dcdeae1ad88 -->
# GPUグリッド占有ベース疎点除去（1回／StructureManager連結／単一ComputeShader）

## 目的

- 3D占有グリッドで疎点を除去するGPUコンピュート処理（最悪 O(N)）。
- 上流 `StructureManager.OnReady` を受け取り、1回だけRefineして自身の `OnReady` で再配信。
- フォールバックは一切なし。重大な判断が必要な状況は例外で停止し、あなたに確認する。

## 追加／変更ファイル

- 追加: `Assets/Shaders/PointRefineOne.compute`（AABB縮約＋占有＋コンパクションを包含）
- 追加: `Assets/Scripts/Structure/GridRefineManager.cs`（`StructureManager` 継承）

## Compute Shader: PointRefineOne.compute（単一アセット内で完結）

- カーネル（同一フレーム内で順序ディスパッチ）:
- `KReduceAabbGroups`: 各グループで min/max 縮約 → `_AabbScratch` へ書き出し
- `KReduceAabbFinal`: `_AabbScratch` を最終 min/max に縮約 → `_Min`, `_Max`
- `KClearOccupancy`: `_Occupancy` を0初期化
- `KBuildOccupancy`: 各点 → セルに `atomicAdd(_Occupancy[cell],1)`
- `KRefineCompact`: 各点 → `(2R+1)^3` 近傍セル合計（球/立方体はパラメータ）。保持なら `InterlockedAdd(_Counter[0],1,base)` → `_PointsOut[base]=_PointsIn[i]`
- パラメータ（マジックナンバー禁止）:
- `_CellSize`(m), `_KernelRadiusCells`(uint), `_MinNeighbors`, `_MaxNeighbors`, `_UseSphericalKernel`(bool)
- `_Count`(uint)
- 派生値／出力:
- `_Min`(float3), `_Max`(float3)（AABB結果）
- `_GridOrigin`(float3), `_GridDim`(uint3)（C#側で算出しセット）
- バッファ（全てStructuredBuffer。中間RT禁止）:
- `StructuredBuffer<float4> _PointsIn`（xyz: m, w: r[m]）
- `RWStructuredBuffer<uint> _Occupancy`（3Dフラット）
- `RWStructuredBuffer<float4> _PointsOut`
- `RWStructuredBuffer<uint> _Counter`（1要素）
- `RWStructuredBuffer<float3> _AabbScratch`（グループ数分）
- 実装方針:
- スレッドグループサイズは命名定数。
- 分岐は極力 `step` マスクで回避。
- 同一ComputeShader内で全工程を連続ディスパッチ（タイミング依存を排除）。

## 実行順序（同一コマンド内で順次）

1) `KReduceAabbGroups`
2) `KReduceAabbFinal` → `_Min/_Max` をCPUへ読み戻し
3) C#で `_GridOrigin = _Min - boundsMargin`, `dim = ceil((_Max - _Min + 2*boundsMargin)/_CellSize)+1` を算出しセット
4) `KClearOccupancy` → `KBuildOccupancy` → `KRefineCompact`
5) `counter` 読み戻し → 出力 `PointCloud` 構築

## C#統合（GridRefineManager.cs）

- Serializedパラメータ:
- `StructureManager upstream`
- `float cellSize`, `uint kernelRadiusCells`, `uint minNeighbors`, `uint maxNeighbors`
- `float boundsMargin`, `int maxCellsMB`, `bool useSphericalKernel`
- ライフサイクル（1回限り）:
- `OnEnable`: `upstream.OnReady += OnUpstreamReady`
- `OnDisable`: 購読解除
- 初回実行後に購読解除し、二度目は実行しない。
- `OnUpstreamReady(PointCloud pc)` フロー:
1) 一時バッファ確保（`_AabbScratch`, `_Occupancy`, `_Counter`, `_PointsOut`）
2) `KReduceAabbGroups` → `KReduceAabbFinal` → `_Min/_Max` 読み戻し
3) グリッド算出・メモリ上限チェック（`maxCellsMB`超過は例外） → `_GridOrigin/_GridDim` をセット
4) `KClearOccupancy` → `KBuildOccupancy` → `KRefineCompact`
5) `counter` 読み戻し → `outCount` に合わせて出力GPUバッファを確保して転送 → 新 `PointCloud` 生成
6) 一時破棄 → `InvokeReady(refinedPc)` → 購読解除
- 例外方針: 設定不正、メモリ上限超過、必要リソース未設定などは例外で即停止（フォールバック禁止）。

## To-do（最小実装）

- [ ] `PointRefineOne.compute` を作成（5カーネル／定数化・分岐回避・バッファのみ）
- [ ] `GridRefineManager.cs` を作成（OnReady連結→1回Refine→再配信・購読解除）
- [ ] グリッド算出・メモリガード・例外実装・バッファ確保〜ディスパッチ〜新PointCloud構築

### To-dos

- [ ] Create PointGridRefine.compute with KClearOccupancy, KBuildOccupancy, KRefineCompact
- [ ] Create GridRefineManager that chains upstream OnReady and emits refined cloud
- [ ] Implement AABB acquisition and grid sizing with memory guard
- [ ] Allocate buffers, dispatch kernels, read back count, build new PointCloud
- [ ] Expose serialized params (cellSize, kernelRadiusCells, thresholds, limits)
- [ ] Validate output and perf on target data; tune defaults